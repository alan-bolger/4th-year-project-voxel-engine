#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

struct box 
{
    vec3 min;
    vec3 max;
    vec3 center;
    vec3 surfaceColour;
    vec3 emissionColour;
    float transparency;
    float reflection;
};

#define MAX_SCENE_BOUNDS 100.0
#define NUM_BOXES 19

vec3 boundingBoxSize = vec3(0.5, 0.5, 0.5);

const box boxes[] = 
{
    {vec3(-10, -1, -10), vec3(10, 1, 10), vec3(10, -1, 10), vec3(1.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5), 0.0, 1.0},  
    {vec3(-6, 2, -6) - boundingBoxSize, vec3(-6, 2, -6) + boundingBoxSize, vec3(-6, 2, -6), vec3(0.0, 1.0, 0.0), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(-3, 2, -6) - boundingBoxSize, vec3(-3, 2, -6) + boundingBoxSize, vec3(-3, 2, -6), vec3(0.0, 0.0, 1.0), vec3(0.5, 0.5, 0.5), 0.0, 1.0},  
    {vec3(0, 2, -6) - boundingBoxSize, vec3(0, 2, -6) + boundingBoxSize, vec3(0, 2, -6), vec3(1.0, 1.0, 0.0), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(3, 2, -6) - boundingBoxSize, vec3(3, 2, -6) + boundingBoxSize, vec3(3, 2, -6), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(6, 2, -6) - boundingBoxSize, vec3(6, 2, -6) + boundingBoxSize, vec3(6, 2, -6), vec3(0.73, 0.16, 0.96), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(-4.5, 4, -6) - boundingBoxSize, vec3(-4.5, 4, -6) + boundingBoxSize, vec3(-4.5, 4, -6), vec3(0.196078, 0.8, 0.196078), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(-1.5, 4, -6) - boundingBoxSize, vec3(-1.5, 4, -6) + boundingBoxSize, vec3(1.5, 4, -6), vec3(0.647059, 0.164706, 0.164706), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(1.5, 4, -6) - boundingBoxSize, vec3(1.5, 4, -6) + boundingBoxSize, vec3(1.5, 4, -6), vec3(0.556863, 0.137255, 0.137255), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(4.5, 4, -6) - boundingBoxSize, vec3(4.5, 4, -6) + boundingBoxSize, vec3(4.5, 4, -6), vec3(0.196078, 0.6, 0.8), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(-3.0, 6, -6) - boundingBoxSize, vec3(-3.0, 6, -6) + boundingBoxSize, vec3(-3.0, 6, -6), vec3(0.847059, 0.847059, 0.74902), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(0.0, 6, -6) - boundingBoxSize, vec3(0.0, 6, -6) + boundingBoxSize, vec3(0.0, 6, -6), vec3(0.85, 0.85, 0.10), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(3.0, 6, -6) - boundingBoxSize, vec3(3.0, 6, -6) + boundingBoxSize, vec3(3.0, 6, -6), vec3(0.96, 0.80, 0.69), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(-1.5, 8, -6) - boundingBoxSize, vec3(-1.5, 8, -6) + boundingBoxSize, vec3(-1.5, 8, -6), vec3(0.137255, 0.137255, 0.556863), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(1.5, 8, -6) - boundingBoxSize, vec3(1.5, 8, -6) + boundingBoxSize, vec3(1.5, 8, -6), vec3(0.658824, 0.658824, 0.658820), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(0.0, 10.0, -6) - boundingBoxSize, vec3(0.0, 10.0, -6) + boundingBoxSize, vec3(0.0, 10.0, -6), vec3(0.137255, 0.556863, 0.419608), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(-6, 2, 4) - boundingBoxSize, vec3(-6, 2, 4) + boundingBoxSize, vec3(-6, 2, 4), vec3(0.71, 0.65, 0.26), vec3(0.5, 0.5, 0.5), 0.0, 1.0},
    {vec3(6, 2, 4) - boundingBoxSize, vec3(6, 2, 4) + boundingBoxSize, vec3(6, 2, 4), vec3(0.52, 0.37, 0.26), vec3(0.5, 0.5, 0.5), 0.0, 1.0}, 
    {vec3(0.0, 2, 6) - boundingBoxSize, vec3(0.0, 2, 6) + boundingBoxSize, vec3(0.0, 2, 6), vec3(0.13, 0.37, 0.31), vec3(0.5, 0.5, 0.5), 0.0, 1.0}
};

struct hitinfo 
{
    vec2 lambda;
    int bi;
    vec3 center;
    vec3 surfaceColour;
    vec3 emissionColour;
    float transparency;
    float reflection;
};

vec2 intersectBox(vec3 origin, vec3 dir, const box b) 
{
    vec3 tMin = (b.min - origin) / dir;
    vec3 tMax = (b.max - origin) / dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) 
{
    float smallest = MAX_SCENE_BOUNDS;
    bool found = false;
    
    for (int i = 0; i < NUM_BOXES; i++)
    {
        vec2 lambda = intersectBox(origin, dir, boxes[i]);

        if (lambda.x > 0.0 && lambda.x < lambda.y && lambda.x < smallest)
        {
            info.lambda = lambda;
            info.bi = i;
            smallest = lambda.x;
            info.center = boxes[i].center;
            info.surfaceColour = boxes[i].surfaceColour;
            info.emissionColour = boxes[i].emissionColour;
            info.transparency = boxes[i].transparency;
            info.reflection = boxes[i].reflection;
            found = true;
        }
    }

    return found;
}

vec4 trace(vec3 origin, vec3 dir) 
{
    hitinfo i;

    if (intersectBoxes(origin, dir, i))
    {
        vec4 colour = vec4(i.surfaceColour, 1.0);
        return vec4(colour.rgb, 1.0);
    }

    return vec4(0.329412, 0.329412, 0.329412, 1.0);
}

layout (local_size_x = 16, local_size_y = 8) in;

void main(void) 
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    
    if (pix.x >= size.x || pix.y >= size.y) 
    {
        return;
    }
    
    vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
    vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
    vec4 colour = trace(eye, dir);
    imageStore(framebuffer, pix, colour);
}
