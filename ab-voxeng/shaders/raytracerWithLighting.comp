#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

struct sphere 
{
    vec3 center;
    float radius;
    float radius2;
    vec3 surfaceColour;
    vec3 emissionColour;
    float transparency;
    float reflection;
};

#define PI 3.141592653589793 
#define INFINITY 1e8 
#define MAX_SCENE_BOUNDS 100.0
#define MAX_RAY_DEPTH 5
#define NUM_SPHERES = 4

vec3 boundingBoxSize = vec3(0.5, 0.5, 0.5);
int depth;

const sphere spheres[] = 
{
    { vec3(0, 0, 0), 5.0, 25.0, vec3(1, 1, 1), vec3(1, 1, 1), 0.0, 0.0 },
    { vec3(10, 0, 0), 5.0, 25.0, vec3(1, 1, 1), vec3(1, 1, 1), 0.0, 0.0 },
    { vec3(0, 0, 10), 5.0, 25.0, vec3(1, 1, 1), vec3(1, 1, 1), 0.0, 0.0 },
    { vec3(0, 10, 0), 5.0, 25.0, vec3(1, 1, 1), vec3(1, 1, 1), 0.0, 0.0 }
};

struct hitinfo 
{
    vec2 nearFar;
    int bi;
    vec3 center;
    vec3 surfaceColour;
    vec3 emissionColour;
    float transparency;
    float reflection;
};

bool intersect(vec3 rayorig, vec3 raydir, float t0, float t1, sphere sphereObj) 
{
    vec3 l = sphereObj.center - rayorig; 
    float tca = dot(l, raydir); 

    if (tca < 0)
    {
        return false;
    }
     
    float d2 = dot(l, l) - tca * tca; 

    if (d2 > sphereObj.radius2) 
    {
        return false; 
    }    

    float thc = sqrt(sphereObj.radius2 - d2); 
    t0 = tca - thc; 
    t1 = tca + thc; 
    
    return true; 
}

vec3 trace(vec3 rayorig, vec3 raydir, int depth) 
{ 
    //if (raydir.length() != 1) std::cerr << "Error " << raydir << std::endl;
    float tnear = INFINITY; 
    sphere tempSphere;
   
    for (int i = 0; i < NUM_SPHERES; ++i)
    { 
        float t0 = INFINITY;
        float t1 = INFINITY; 

        if (intersect(rayorig, raydir, t0, t1), spheres[i]) 
        { 
            if (t0 < 0)
            {
                t0 = t1;
            }             

            if (t0 < tnear) 
            { 
                tnear = t0; 
                tempSphere = spheres[i]; 
            }
        } 
    }
    // if there's no intersection return black or background color
    //if (!sphere) return Vec3f(2); 
    vec3 surfaceColor = vec3(0, 0, 0);
    vec3 phit = rayorig + raydir * tnear;
    vec3 nhit = phit - tempSphere.center; // normal at the intersection point 
    nhit = normalize(nhit);
    float bias = 1e-4; // add some bias to the point from which we will be tracing 
    bool inside = false; 

    if (dot(raydir, nhit) > 0)
    {
        nhit = -nhit;
        inside = true; 
    }    

    if ((tempSphere.transparency > 0 || tempSphere.reflection > 0) && depth < MAX_RAY_DEPTH)
    { 
        float facingratio = dot(-raydir, nhit);
        float fresneleffect = mix(pow(1.0 - facingratio, 3.0), 1.0, 0.1);
        vec3 refldir = raydir - nhit * 2 * dot(raydir, nhit); 
        refldir = normalize(refldir); 
        // vec3 reflection = trace(phit + nhit * bias, refldir, spheres, depth + 1); // This requires recursive calls and OpenGL don't support that shit
        vec3 refraction = vec3(0, 0, 0);

        if (tempSphere.transparency == 1)
        { 
            float ior = 1.1;
            float eta = (inside) ? ior : 1 / ior; // are we inside or outside the surface? 
            float cosi = dot(-nhit, raydir); 
            float k = 1 - eta * eta * (1 - cosi * cosi); 
            vec3 refrdir = raydir * eta + nhit * (eta *  cosi - sqrt(k)); 
            refrdir = normalize(refrdir); 
            // refraction = trace(phit - nhit * bias, refrdir, spheres, depth + 1); // This requires recursive calls and OpenGL don't support that shit
        }
        // the result is a mix of reflection and refraction (if the sphere is transparent)
        surfaceColor = (reflection * fresneleffect + refraction * (1 - fresneleffect) * tempSphere.transparency) * tempSphere.surfaceColour; 
    } 
    else 
    { 
        // it's a diffuse object, no need to raytrace any further
        for (unsigned int i = 0; i < NUM_SPHERES; ++i)
        { 
            if (spheres[i].emissionColor.x > 0) 
            { 
                // this is a light
                vec3 transmission = vec3(1, 1, 1); 
                vec3 lightDirection = spheres[i].center - phit; 
                lightDirection = normalize(lightDirection); 

                for (unsigned int j = 0; j < NUM_SPHERES; ++j) 
                { 
                    if (i != j) 
                    { 
                        float t0, t1; 
                        if (intersect(phit + nhit * bias, lightDirection, t0, t1, spheres[j]))
                        { 
                            transmission = vec3(0, 0, 0); 
                            break; 
                        } 
                    } 
                } 

                surfaceColor += tempSphere.surfaceColour * transmission * max(float(0), dot(nhit, lightDirection)) * spheres[i].emissionColour; 
            } 
        } 
    } 
 
    return surfaceColor + sphere.emissionColour; 
}

layout (local_size_x = 16, local_size_y = 8) in;

void main(void) 
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    
    if (pix.x >= size.x || pix.y >= size.y) 
    {
        return;
    }

    int width = 640;
    int height = 480; 
    float invWidth = 1 / float(width), invHeight = 1 / float(height); 
    float fov = 30;
    float aspectratio = width / float(height); 
    float angle = tan(PI * 0.5 * fov / 180.0); 

    // Trace rays
    float xx = (2 * ((pix.x + 0.5) * invWidth) - 1) * angle * aspectratio; 
    float yy = (1 - 2 * ((pix.y + 0.5) * invHeight)) * angle; 
    vec3 raydir = vec3(xx, yy, -1); 
    raydir = normalize(raydir);
    vec3 pixel = trace(eye, raydir, depth);
    imageStore(framebuffer, pix, pixel);
}
